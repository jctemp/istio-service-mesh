{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This repository gives more context regarding the setup of Istio's ambient and traditional service mesh experiment. It uses the <code>book info</code> example to demonstrate the performance difference between the two service meshes. Further, it is essential to note that this is an academic example and that real environment benchmarks are necessary to understand proper behaviour. Nonetheless, the benchmark aims to show the new approach's tendencies and opportunities.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>You are required to install the listed software below to run the benchmarks. See the section <code>Prerequisites</code> for more information. Feel free to skip if you have the required software installed.</p> <ul> <li>Docker Version 20.10.23</li> <li>Kubernetes CLI Version 1.26.1</li> <li>Go Version 1.19.5</li> <li>kind Version v0.17.0</li> <li>k9s Version 0.27.0 (optional)</li> </ul>"},{"location":"02-sources/","title":"Sources","text":"<p>These are the source that were used to setup the service mesh.</p> <ul> <li>Ambient mesh setup</li> <li>Ambient mesh introduction</li> <li>Dashboard setup</li> </ul>"},{"location":"03-environment/","title":"Environment","text":"<p>Info</p> <p>Using a virtual environment can cause unexpected behaviour. Even a setup on a native OS can still cause problems that are probably correlated to the preview version. Therefore, it is interesting to see how the upcoming release of the ambient mesh looks and if it provides better support.</p> <p>We used a VPS with four cores and 8GB of RAM for the benchmark. The installed OS is Ubuntu 22.04.1, as it offers the best compatibility. Details of the VPS are listed below.</p> <pre><code>OS:     Ubuntu 22.04.1 LTS x86_64\nHost:   KVM/QEMU (Standard PC (i440FX + PIIX, 1996) \nKernel: 5.15.0-25-generic\nShell:  bash 5.1.16\nCPU:    AMD EPYC 7282 (4) @ 2.794GHz\nMemory: 377MiB / 7951MiB\n</code></pre>"},{"location":"04-prerequisites/","title":"Quick guide","text":"<p>This section is a quick guide to installing all the dependencies. The given instructions are only for Debian-based systems. Although we provided the collection of all the needed commands, we do not guarantee correctness. Therefore, consult the official websites if you need help with problems.</p>"},{"location":"04-prerequisites/#system","title":"System","text":"<p>First, we can install basic packages via the native package manager <code>apt</code>. The tools <code>docker</code> and <code>kubectl</code> need these packages to function correctly.</p> <pre><code>sudo apt -y update\nsudo apt -y install ca-certificates curl gnupg lsb-release\n</code></pre>"},{"location":"04-prerequisites/#docker","title":"Docker","text":"<p>Docker will manage the containers of the deployed cluster. The docker documentation recommends removing any existing docker installation to have the correct version.</p> <pre><code>sudo apt remove docker docker-engine docker.io containerd runc\n</code></pre> <p>The next step is to add the docker signing key to the package manager and make the native package manager aware of the docker repository.</p> <pre><code>mkdir -p /etc/apt/keyrings\ncurl -fsSL \"https://download.docker.com/linux/ubuntu/gpg\" |\nsudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \"https://download.docker.com/linux/ubuntu\" \\\n$(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt;/dev/null\n</code></pre> <p>Finally, the documentation explained that we must change the installation pattern if we do not want the latest version. So feel free to adapt this section to your needs.</p> <pre><code>sudo apt -y update\n\nVERSION_STRING=5:20.10.23~3-0~ubuntu-jammy\nVERSION_AVAILABLE=$(apt-cache madison docker-ce | awk '{ print $3 }')\nif echo $VERSION_AVAILABLE | grep -q \"$VERSION_STRING\"; then sudo apt -y install \\\ndocker-ce=$VERSION_STRING \\\ndocker-ce-cli=$VERSION_STRING \\\ncontainerd.io \\\ndocker-compose-plugin; else\necho \"Could not find $VERSION_STRING.\"\nfi\n</code></pre> <p>Post-installation, depending on the system, it might be necessary to add the current user to a <code>docker</code> group which will grant access to the docker socket.</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre>"},{"location":"04-prerequisites/#kubectl","title":"Kubectl","text":"<p>To work with any cluster, we must install the Kubernetes command-line tool <code>kubectl</code>. The easiest method is to curl the binary, as it can ensure the same version.</p> <pre><code>VERSION=v1.26.1\n\ncurl -LO \"https://dl.k8s.io/release/$VERSION/bin/linux/amd64/kubectl\"\ncurl -LO \"https://dl.k8s.io/$VERSION/bin/linux/amd64/kubectl.sha256\"\n</code></pre> <p>Verify the downloaded executable <code>kubectl</code>.</p> <pre><code>echo \"$(cat kubectl.sha256) kubectl\" | sha256sum --check\n</code></pre> <p>Now, we can use the <code>install</code> command to add the <code>kubectl</code> executable to the local binaries path.</p> <pre><code>sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n</code></pre>"},{"location":"04-prerequisites/#kind","title":"Kind","text":"<p>Next, we need an environment to create a cluster. Note that you can use cloud services instead. The <code>kind</code> tool (Kubernetes in Docker) allows us to create a local cluster. Alternatives are <code>k3d</code> or <code>minikube</code>, but during testing <code>kind</code> delivered the most reliable results.</p> <p>Similar to the <code>kubectl</code> executable, we will curl the <code>kind</code> binary.</p> <pre><code>VERSION=v0.17.0\nFILE=kind-linux-amd64\n\ncurl -Lo ./$FILE \"https://github.com/kubernetes-sigs/kind/releases/download/$VERSION/$FILE\"\ncurl -Lo ./$FILE.sha256 \"https://github.com/kubernetes-sigs/kind/releases/download/$VERSION/$FILE.sha256sum\"\n</code></pre> <p>Verify the downloaded executable <code>kind</code>.</p> <pre><code>echo \"$(cat $FILE.sha256)\" | sha256sum --check\n</code></pre> <p>Now, we can use the <code>install</code> command to add the <code>kubectl</code> executable to the local binaries path.</p> <pre><code>sudo install -o root -g root -m 0755 $FILE /usr/local/bin/kind\n</code></pre>"},{"location":"04-prerequisites/#k9s","title":"k9s","text":"<p>As previously mentioned, this part is optional. The <code>k9s</code> command line interface provides comfortable tooling with an excellent cluster overview. Nonetheless, working solely with <code>kubectl</code> is sufficient. Download the binary and unpack it.</p> <pre><code>FILE=k9s_Linux_amd64.tar.gz\ncurl -LO \"https://github.com/derailed/k9s/releases/download/v0.27.0/$FILE\"\ntar -xzf $FILE\n</code></pre> <p>Finally, install it.</p> <pre><code>sudo install -o root -g root -m 0755 ./k9s /usr/local/bin/k9s\n</code></pre>"},{"location":"05-clusters/","title":"Creating clusters","text":"<p>It is necessary to download a particular preview version to create a cluster with ambient mesh functionalities. The current Istio version <code>1.16.2</code> already supports the new communication protocol <code>HBONE</code>, but it does not contain the ztunnels.</p> <pre><code>FILE=\"istio-0.0.0-ambient.191fe680b52c1754ee72a06b3e0d3f9d116f2e82-linux-amd64.tar.gz\"\nURL=\"https://storage.googleapis.com/istio-build/dev/0.0.0-ambient.191fe680b52c1754ee72a06b3e0d3f9d116f2e82\"\ncurl -LO \"$URL/$FILE\"\ncurl -LO \"$URL/$FILE.sha256\"\n</code></pre> <p>Verify the downloaded preview version.</p> <pre><code>echo $(cat $FILE.sha256) | sha256sum --check\n</code></pre> <p>Unpack the compressed tarball and enter the directory.</p> <pre><code>DEST=istio-0.0.0-ambient\nmkdir $DEST &amp;&amp; tar xzf $FILE --strip-components 1 -C $DEST &amp;&amp; cd $DEST\n</code></pre> <p>Tip</p> <p>You can create a symlink to the <code>istioctl</code> executable and add it to the <code>/usr/local/bin</code> path to make it available globally. Like that you are not required to type the path to the binary.</p> <pre><code>sudo ln -s $(pwd)/bin/istioctl /usr/local/bin/istioctl\n</code></pre>"},{"location":"05-clusters/#handling-clusters","title":"Handling clusters","text":"<p>Next, we want to be able to create different clusters. Therefore, make a new file called <code>template.yaml</code> and add the code below.</p> template.yaml<pre><code>kind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\n# Identifier of the cluster\nname: {name}\n# Create three nodes\nnodes:\n- role: control-plane\n- role: worker\n- role: worker\n</code></pre> <p>With that template, we can create three distinct versions of the file, where we change the name of the cluster. We need the three nodes for the <code>book info</code> example.</p> <pre><code>for NAME in \"ambient\" \"ambient-waypoint\" \"traditional\"; do\ncp ./template.yaml ./$NAME.yaml\n    SED_STR=\"s/{name}/$NAME/g\"\nsed -i -e \"$SED_STR\" ./$NAME.yaml\ndone\n</code></pre> <p>Finally, we can use the <code>kind</code> tool to create a local cluster based on the configuration file.</p> <pre><code>NAME=\"ambient\"\nkind create cluster --config $NAME.yaml\n</code></pre> <p>After creating a cluster, we can use the <code>k9s</code> tool to browse the various components. At this point, it should be empty as only the essential services are deployed to operate the cluster with <code>kubectl</code>. Further valuable commands are:</p> <pre><code># list all available clusters\nkind get clusters\n\n# delete a cluster\nkind delete clusters &lt;name&gt;\n</code></pre> <p>The last step before deploying the application is to install an Istio profile in the cluster. You can list all the available profiles with <code>istioctl profile list</code>. It also should contain the ambient profile. Finally, install Istio will the following command:</p> <pre><code>istioctl install -y --set profile=ambient\n</code></pre>"},{"location":"05-clusters/#deployment-of-the-application","title":"Deployment of the application","text":"<p>For the benchmarking, we will use the <code>book info</code> example because Istio well documented references. We have below two guides the explain the deployment of the application. The traditional guide has a more detailed explaination about the <code>book info</code> example. Further, the ambient guide can be some times errorness and troubleshooting was difficult.</p> <ul> <li>traditional guide</li> <li>ambient guide</li> </ul>"},{"location":"05-clusters/#metric-observation-of-a-cluster","title":"Metric observation of a cluster","text":"<p>Ensure you have installed the Istio service mesh because otherwise this installation will fail. Istio provides with every release an addons folder. Inside that folder, there are pre-made <code>.yaml</code> files which deploy <code>Prometheus</code> and <code>Grafana</code> that allow the observation of a cluster. Note that these presets are only helpful for small-scale clusters and should be sufficient for this test.</p> <pre><code>kubectl apply -f ./samples/addons/grafana.yaml\nkubectl apply -f ./samples/addons/prometheus.yaml\n</code></pre> <p>These two add-ons aim to monitor the system's resource usage and visualise the data accordingly. We could optimise the add-ons; However, this should be optional for this scale.</p> <p>TODO (better dashboard for grafana)</p>"},{"location":"06-benchmarks/","title":"Benchmarks","text":""}]}